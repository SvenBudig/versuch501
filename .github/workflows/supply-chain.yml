name: supply-chain-lab

on:
  push:
    branches: ["main"]
  workflow_dispatch:

permissions:
  contents: read
  packages: write
  id-token: write

jobs:
  pipeline:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # Phase 0: Runterladen (CI-geeignet)
      - name: Install Task (go-task)
        uses: go-task/setup-task@v1
        with:
          version: 3.x

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Verify base tools
        shell: bash
        run: |
          set -euo pipefail
          task --version
          docker --version
          git --version
          jq --version
          openssl version

      # -------------------------
      # Phase 1: Security Scans
      # -------------------------
      - name: Build scan tools
        shell: bash
        run: |
          set -euo pipefail
          task build-tools

      - name: Run all security scans (fail pipeline on HIGH/CRITICAL)
        shell: bash
        run: |
          set -euo pipefail
          task scan-all

      - name: Build application
        shell: bash
        run: |
          set -euo pipefail
          task build

      - name: Build container image
        shell: bash
        run: |
          set -euo pipefail
          task build-image

      # -------------------------
      # Phase 2: Provenance + SBOM + Vuln-Predicates + Validation
      # -------------------------
      - name: Create docker-container buildx builder (für Provenance/SBOM)
        shell: bash
        run: |
          set -euo pipefail
          docker buildx create --name container-builder --driver docker-container --use
          docker buildx inspect --bootstrap

      - name: Build image with attestation artifacts in out/
        shell: bash
        run: |
          set -euo pipefail
          task build-image-with-attestation
          test -f out/provenance.json
          test -f out/sbom.spdx.json

      - name: Prepare attestations folder
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p attestations

      - name: Extract provenance predicate
        shell: bash
        run: |
          set -euo pipefail
          cat out/provenance.json | jq .predicate | tee attestations/provenance.json >/dev/null
          test -s attestations/provenance.json

      - name: Validate provenance
        shell: bash
        run: |
          set -euo pipefail
          task validate:provenance

      - name: Extract SBOM predicate (SPDX)
        shell: bash
        run: |
          set -euo pipefail
          jq '.predicate' out/sbom.spdx.json > attestations/sbom.json
          test -s attestations/sbom.json

      - name: Quick SBOM sanity checks
        shell: bash
        run: |
          set -euo pipefail
          jq 'keys' attestations/sbom.json >/dev/null
          jq -r '.spdxVersion' attestations/sbom.json
          jq '.packages | length' attestations/sbom.json
          jq '.packages[5:20] | .[] | {name, versionInfo}' attestations/sbom.json

      - name: Validate SBOM
        shell: bash
        run: |
          set -euo pipefail
          task validate:sbom

      - name: Generate vulnerability predicates (source, IaC, image)
        shell: bash
        run: |
          set -euo pipefail

          # Source scan -> in-toto predicate
          task exec -- trivy fs --format cosign-vuln src/ > attestations/vuln-source.json
          test -s attestations/vuln-source.json

          # IaC scan -> in-toto predicate
          task exec -- trivy config --format cosign-vuln src/iac/ > attestations/vuln-iac.json
          test -s attestations/vuln-iac.json

          # Image scan -> in-toto predicate (setzt lokales Tag voraus)
          task exec -- trivy image --format cosign-vuln supply-chain-app:latest > attestations/vuln-image.json
          test -s attestations/vuln-image.json

      - name: Validate all attestations
        shell: bash
        run: |
          set -euo pipefail
          task validate:all-attestations

           # -------------------------
      # Phase 3: Signieren + Transparenz (Fulcio / Rekor) + Verifikation
      # (ohne task exec, damit GHCR-Login des Runners genutzt wird)
      # -------------------------

      # Cosign installieren (Sigstore Client)
      - name: Installiere Cosign
        uses: sigstore/cosign-installer@v3
        with:
          cosign-release: "v2.6.2"

      # Rekor CLI installieren (Transparenz-Log)
      - name: Installiere Rekor CLI
        shell: bash
        run: |
          set -euo pipefail
          REKOR_VERSION="v1.3.6"
          curl -sSfL "https://github.com/sigstore/rekor/releases/download/${REKOR_VERSION}/rekor-cli-linux-amd64" -o rekor-cli
          chmod +x rekor-cli
          sudo mv rekor-cli /usr/local/bin/rekor-cli
          rekor-cli version
          cosign version

      # In GHCR einloggen (für Push + Pull/Resolve durch Cosign)
      - name: Login bei GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Image nach GHCR pushen und Digest ermitteln
      - name: Push Image zu GHCR und Digest ermitteln
        id: push
        shell: bash
        run: |
          set -euo pipefail

          # GHCR verlangt lowercase repository-Namen
          OWNER_RAW="${{ github.repository_owner }}"
          OWNER="$(echo "${OWNER_RAW}" | tr '[:upper:]' '[:lower:]')"

          # Image-Name bleibt bewusst "supply-chain-app"
          IMAGE_REPO="ghcr.io/${OWNER}/supply-chain-app"
          TAG="${{ github.sha }}"

          # Sicherstellen, dass das lokale Image existiert
          docker image inspect supply-chain-app:latest >/dev/null

          docker tag supply-chain-app:latest "${IMAGE_REPO}:${TAG}"
          docker push "${IMAGE_REPO}:${TAG}" 2>&1 | tee /tmp/push-output.txt

          DIGEST="$(grep -m1 'digest:' /tmp/push-output.txt | awk '{print $3}')"
          test -n "${DIGEST}"

          IMAGE="${IMAGE_REPO}@${DIGEST}"

          echo "DIGEST=${DIGEST}" >> "$GITHUB_ENV"
          echo "IMAGE=${IMAGE}" >> "$GITHUB_ENV"

          echo "Image: ${IMAGE}"

      # Image signieren (keyless via GitHub OIDC + Fulcio) und direkt verifizieren
      # Hinweis: validate:phase3 erwartet, dass eine Image-Signatur (cosign/sign/v1) am Digest sichtbar ist.
      - name: Container-Image signieren + verifizieren (Cosign, keyless)
        shell: bash
        env:
          COSIGN_EXPERIMENTAL: "true"
        run: |
          set -euo pipefail

          # 1) Image signieren und Rekor Upload erzwingen
          #cosign sign --yes --tlog-upload=true "${IMAGE}"
          cosign sign --yes ${IMAGE}
          

          # 2) Sofort verifizieren (liefert JSON inkl. cosign/sign/v1)
          cosign verify --experimental-oci11 \
            --certificate-identity-regexp=".*" \
            --certificate-oidc-issuer-regexp=".*" \
            "${IMAGE}" | jq

          # 3) Fallback: recursive sign (hilft bei Registry-Referrer-Eigenheiten)
          #    (wird nicht als Fehler gewertet, falls es bereits korrekt ist)
          cosign sign --yes --recursive --tlog-upload=true "${IMAGE}" || true

      - name: Cosign Tree anzeigen (Referrers prüfen)
        shell: bash
        env:
          COSIGN_EXPERIMENTAL: "true"
        run: |
          set -euo pipefail
          cosign tree --experimental-oci11 "${IMAGE}" || true

      # Provenance-Attestation signieren
      - name: Provenance Attestation signieren
        shell: bash
        env:
          COSIGN_EXPERIMENTAL: "true"
        run: |
          set -euo pipefail
          test -s attestations/provenance.json
          cosign attest --yes \
            --type slsaprovenance \
            --predicate attestations/provenance.json \
            "${IMAGE}"

      # SBOM-Attestation signieren
      - name: SBOM Attestation signieren
        shell: bash
        env:
          COSIGN_EXPERIMENTAL: "true"
        run: |
          set -euo pipefail
          test -s attestations/sbom.json
          cosign attest --yes \
            --type spdxjson \
            --predicate attestations/sbom.json \
            "${IMAGE}"

      # Vulnerability-Attestations signieren (3x)
      - name: Vulnerability Attestations signieren (Source/IaC/Image)
        shell: bash
        env:
          COSIGN_EXPERIMENTAL: "true"
        run: |
          set -euo pipefail
          test -s attestations/vuln-source.json
          test -s attestations/vuln-iac.json
          test -s attestations/vuln-image.json

          cosign attest --yes --type vuln --predicate attestations/vuln-source.json "${IMAGE}"
          cosign attest --yes --type vuln --predicate attestations/vuln-iac.json "${IMAGE}"
          cosign attest --yes --type vuln --predicate attestations/vuln-image.json "${IMAGE}"

      # Rekor-Log prüfen (mit Retry, da Rekor manchmal verzögert ist)
      - name: Rekor-Einträge prüfen (mit Retry)
        shell: bash
        run: |
          set -euo pipefail
          HASH="$(echo "${DIGEST}" | cut -d: -f2)"
          echo "Rekor search SHA: ${HASH}"

          for i in 1 2 3 4 5 6 7 8 9 10; do
            OUT="$(rekor-cli search --sha "${HASH}" 2>/dev/null || true)"
            if echo "${OUT}" | grep -q .; then
              echo "${OUT}"
              exit 0
            fi
            echo "Noch keine Rekor-Einträge sichtbar (Versuch ${i}/10). Warte 5s..."
            sleep 5
          done

          echo "Keine Rekor-Einträge gefunden."
          exit 1

      #Erneuter Debug
      # Add this as a step inside your GitHub Actions job (after you set IMAGE/DIGEST)
      - name: Debug Phase 3 (signature, attestations, rekor)
        shell: bash
        env:
          IMAGE: ${{ env.IMAGE }}
          DIGEST: ${{ env.DIGEST }}
        run: |
          set -euo pipefail
      
          echo "=== DEBUG: inputs ==="
          echo "IMAGE=${IMAGE:-<unset>}"
          echo "DIGEST=${DIGEST:-<unset>}"
          echo ""
      
          if [ -z "${DIGEST:-}" ]; then
            echo "❌ DIGEST not set"
            exit 1
          fi
          if [ -z "${IMAGE:-}" ]; then
            echo "❌ IMAGE not set"
            exit 1
          fi
      
          HASH="$(echo "$DIGEST" | cut -d: -f2)"
          echo "HASH=$HASH"
          echo ""
      
          echo "=== DEBUG: tool versions ==="
          cosign version || true
          rekor-cli version || true
          jq --version || true
          echo ""
      
          echo "=== DEBUG: cosign tree (artifacts attached to IMAGE) ==="
          cosign tree --experimental-oci11 "$IMAGE" || true
          echo ""
      
          echo "=== DEBUG: cosign verify (raw output) ==="
          VERIFY_RAW="$(cosign verify --experimental-oci11 \
            --certificate-identity-regexp='.*' \
            --certificate-oidc-issuer-regexp='.*' \
            "$IMAGE" 2>&1 || true)"
          echo "$VERIFY_RAW"
          echo ""
      
          echo "=== DEBUG: signature objects (cosign/sign/v1) ==="
          JSON_LINES="$(echo "$VERIFY_RAW" | grep -E '^\[.*\]$' || true)"
          if [ -n "$JSON_LINES" ]; then
            SIG_COUNT="$(echo "$JSON_LINES" | jq '[.[] | select(.critical.type=="https://sigstore.dev/cosign/sign/v1")] | length' 2>/dev/null || echo "0")"
            echo "Signature objects found: $SIG_COUNT"
            if [ "$SIG_COUNT" -ge 1 ]; then
              echo "✅ Signature present per verify output"
            else
              echo "❌ No signature object found in verify JSON (cosign/sign/v1)"
            fi
          else
            echo "No JSON array line found in cosign verify output."
            echo "If verify says 'no signatures found', you likely signed a different IMAGE/ref."
          fi
          echo ""
      
          echo "=== DEBUG: attestations (probe by type) ==="
          for T in slsaprovenance spdxjson vuln; do
            echo "--- type=$T ---"
            if cosign verify-attestation --experimental-oci11 \
              --type "$T" \
              --certificate-identity-regexp='.*' \
              --certificate-oidc-issuer-regexp='.*' \
              "$IMAGE" >/dev/null 2>&1; then
              echo "✅ verify-attestation ok for type=$T"
            else
              echo "❌ verify-attestation failed for type=$T"
            fi
          done
          echo ""
      
          echo "=== DEBUG: rekor entries for DIGEST ==="
          REKOR_OUT="$(rekor-cli search --sha "$HASH" 2>/dev/null || true)"
          echo "$REKOR_OUT"
          COUNT="$(echo "$REKOR_OUT" | grep -c '^[a-f0-9]' || echo "0")"
          echo "Rekor entry count: $COUNT"
          echo ""



      # Lab-interne Validierung (muss am Ende laufen)
      - name: Phase 3 Validierung (Lab)
        shell: bash
        run: |
          set -euo pipefail
          task validate:phase3
